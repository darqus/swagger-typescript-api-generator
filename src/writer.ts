import * as fs from 'fs'
import * as path from 'path'
import { TypeDefinitions, TypeDefinition } from './types'

/**
 * Writes the generated TypeScript definitions to a file
 * @param typeDefinitions The generated TypeScript definitions
 * @param outputPath The path to write the definitions to
 */
export async function writeTypesToFile(
  typeDefinitions: TypeDefinitions,
  outputPath: string,
): Promise<void> {
  try {
    const outputDir = path.dirname(outputPath)
    await ensureDirectoryExists(outputDir)

    const content = generateFileContent(typeDefinitions)
    fs.writeFileSync(outputPath, content)
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to write type definitions: ${errorMessage}`)
  }
}

/**
 * Ensures that a directory exists, creating it if necessary
 * @param dir The directory path
 */
async function ensureDirectoryExists(dir: string): Promise<void> {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

/**
 * Generates the file content from the TypeScript definitions
 * @param typeDefinitions The generated TypeScript definitions
 * @returns The file content
 */
function generateFileContent(typeDefinitions: TypeDefinitions): string {
  const content: string[] = []

  content.push('/**')
  content.push(
    ' * This file was automatically generated by swagger-typescript-api-generator',
  )
  content.push(' * DO NOT EDIT DIRECTLY')
  content.push(' */')
  content.push('')

  content.push('/* eslint-disable */')
  content.push('')

  content.push('// Common types')
  content.push('export interface RequestOptions extends RequestInit {')
  content.push('  timeout?: number')
  content.push('}')
  content.push('')

  // Add utility types
  content.push('// Utility types')
  content.push('export type ApiResponse<T> = {')
  content.push('  data: T')
  content.push('  status: number')
  content.push('  statusText: string')
  content.push('  headers: Headers')
  content.push('}')
  content.push('')

  // Sort definitions by dependencies
  const sortedEnums = sortDefinitionsByDependencies(typeDefinitions.enums)
  const sortedInterfaces = sortDefinitionsByDependencies(
    typeDefinitions.interfaces,
  )
  const sortedTypes = sortDefinitionsByDependencies(typeDefinitions.types)
  const sortedApiClasses = typeDefinitions.apiClasses

  // Add enums
  if (sortedEnums.length > 0) {
    content.push('// Enums')
    for (const enumDef of sortedEnums) {
      content.push(enumDef.content)
      content.push('')
    }
  }

  // Add interfaces
  if (sortedInterfaces.length > 0) {
    content.push('// Interfaces')
    for (const interfaceDef of sortedInterfaces) {
      content.push(interfaceDef.content)
      content.push('')
    }
  }

  // Add types
  if (sortedTypes.length > 0) {
    content.push('// Types')
    for (const typeDef of sortedTypes) {
      content.push(typeDef.content)
      content.push('')
    }
  }

  // Add API classes
  if (sortedApiClasses.length > 0) {
    content.push('// API Classes')
    for (const apiClassDef of sortedApiClasses) {
      content.push(apiClassDef.content)
      content.push('')
    }

    // Generate main API class that combines all API classes
    if (sortedApiClasses.length > 1) {
      content.push('/**')
      content.push(' * Main API client that combines all API classes')
      content.push(' */')
      content.push('export class ApiClient {')

      // Import each API class
      for (const apiClassDef of sortedApiClasses) {
        const propName =
          apiClassDef.name.charAt(0).toLowerCase() + apiClassDef.name.slice(1)
        content.push(`  public ${propName}: ${apiClassDef.name}`)
      }

      content.push('')
      content.push("  constructor(baseUrl: string = '') {")

      for (const apiClassDef of sortedApiClasses) {
        const propName =
          apiClassDef.name.charAt(0).toLowerCase() + apiClassDef.name.slice(1)
        content.push(`    this.${propName} = new ${apiClassDef.name}(baseUrl)`)
      }

      content.push('  }')
      content.push('}')
      content.push('')
    }
  }

  return content.join('\n')
}

/**
 * Sorts TypeScript definitions by dependencies
 * @param definitions The TypeScript definitions to sort
 * @returns The sorted TypeScript definitions
 */
function sortDefinitionsByDependencies(
  definitions: TypeDefinition[],
): TypeDefinition[] {
  // Create a map from name to definition
  const definitionMap = new Map<string, TypeDefinition>()
  for (const def of definitions) {
    definitionMap.set(def.name, def)
  }

  // Create a graph of dependencies
  const graph = new Map<string, Set<string>>()
  for (const def of definitions) {
    graph.set(def.name, new Set<string>())

    for (const dependency of def.dependencies) {
      if (definitionMap.has(dependency)) {
        graph.get(def.name)!.add(dependency)
      }
    }
  }

  // Perform topological sort
  const sorted: TypeDefinition[] = []
  const visited = new Set<string>()
  const temp = new Set<string>()

  function visit(name: string) {
    if (temp.has(name)) {
      // Circular dependency detected
      return
    }

    if (visited.has(name)) {
      return
    }

    temp.add(name)

    const dependencies = graph.get(name) || new Set<string>()
    for (const dependency of dependencies) {
      visit(dependency)
    }

    temp.delete(name)
    visited.add(name)

    const def = definitionMap.get(name)
    if (def) {
      sorted.push(def)
    }
  }

  for (const def of definitions) {
    if (!visited.has(def.name)) {
      visit(def.name)
    }
  }

  return sorted.reverse()
}
